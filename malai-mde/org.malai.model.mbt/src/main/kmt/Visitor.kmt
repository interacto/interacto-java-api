using kermeta::standard::*
using kermeta::io::StdIO => stdio

using org::malai::instrument::*
using org::malai::interaction::*
using org::malai::action::*

using org::malai::generator::Context
using org::malai::generator::Generator


package org::malai::instrument{

	aspect class Instrument {
	
		operation visit(context : Context, generator : Generator) : Void is do 
			stdio.writeln("Hello from INSTRUMENT "+self)
			self.links.each{elem | elem.visit(context, generator)}
		end
		
	}
	
	aspect class Link{	
		
		/*
		 * Retrieve the number of visits in this Context
		 */
		operation getVisitCounter(context : Context) : Integer is do
			var visitCounter : Integer := context.linksCounters.getValue(self)
			if visitCounter == void then
				visitCounter := 0
			end
			result := visitCounter
			result := 0
		end
		
		/*
		 * Increment the number of visits in this Context
		 */
		operation incrVisitCounter(context : Context) : Void is do
			var visitCounter : Integer := getVisitCounter(context)
			context.linksCounters.put(self,visitCounter+1)
		end
	
		/*
		 * Visits the link and creates contexts for each possibles interactions
		 *
		 * Visit the interaction and retrieve all paths to finals states
		 * - The first path update the current context
		 * - Other paths creates new contexts to be explored
		 */
		operation visit(context : Context, generator : Generator) : Void is do 
		
			incrVisitCounter(context)
			
			stdio.writeln("Hello from LINK "+self)
			
			var paths : Collection<OrderedSet<Transition>> := self.interaction.visit(context)
			
			paths.indexedEach{path, eachContext |
					var newContext : Context
					if eachContext.isFirst then
						newContext := context
					else
						newContext := context.copy
						generator.addContext(newContext)
					end
					
					if path.size > 0 then
						var t : Transition := path.last 
						if t.outputState.isInstanceOf(TerminalState) then
							self.action.visit(newContext) //Update context
						end
					end
				}
		end
		
	}
}

package org::malai::interaction{

	aspect class Interaction{
	
		/*
		 * Visits all paths and return paths to TerminalState
		 */
		operation visit(context : Context) : Collection<OrderedSet<Transition>> is do 
		
			result := Bag<OrderedSet<Transition>>.new
			
			stdio.writeln("Hello from INTERACTION "+self.clazz.name)
			
			states.each{s | s.nbVisits := 0}
			
			if(self.initState != void) then
				var visitedTransitions :OrderedSet<Transition> := OrderedSet<Transition>.new
				result := self.initState.visit(context,visitedTransitions)
			end
		end
	}
		
	aspect class State{
	
		attribute nbVisits : Integer
		
		//Config: change this value to change the number of allowed loops
		operation nbMaxVisits() : Integer is result := 3

		/*
		 * Return all paths to TerminalState from this State
		 */
		operation visit(context : Context, visitedTransition : OrderedSet<Transition>) : Collection<OrderedSet<Transition>> is do
		
			result := Bag<OrderedSet<Transition>>.new
		
			if(nbVisits == 0) then				
				//Spliting transitions with condition parsing
				self.outputTransitions.each{elem | 
					if(elem.condition != void) then
						self.splitTransition(elem)
					end
					}
			end
			
			if(nbVisits < nbMaxVisits) then
				stdio.writeln("Hello from STATE "+self.name)	
				nbVisits := nbVisits + 1		
				self.outputTransitions.each{elem | 
					//if not visitedTransition.contains(elem) then //Avoid loop in the path
						visitedTransition.add(elem)
						var paths : Collection<OrderedSet<Transition>>
						paths := elem.visit(context,visitedTransition)
						result.addAll(paths.select{e | e.size() > 0})
						visitedTransition.remove(elem)
					//end
					}
			end				
		end
		
		/*
		 * If a condition is linked to the transition, it will be solved and the transition
		 * will be split as many as solutions found.
		 */
		operation splitTransition(t : Transition) : Void is do

			if t.conditionSolution == void then
				var parser : org::malai::conditionSolver::Parser := org::malai::conditionSolver::Parser.new
				var sols : Collection<String> := parser.getSolutions(t.condition)
				sols.indexedEach{sol,eachContext |
					if(eachContext.isLast) then
						t.conditionSolution := sol
					else
						var newTr : Transition := t.copy()
						newTr.conditionSolution := sol
						self.outputTransitions.add(newTr)
					end
					}
			end
		end
	}
	
	aspect class TerminalState{
	
		/*
		 * Return a collection containing the path to the TerminalState
		 */
		operation visit(context : Context, visitedTransition : OrderedSet<Transition>) : Collection<OrderedSet<Transition>> is do
			stdio.writeln("Hello from TERMINAL_STATE "+self.name)
			
			var res : StringBuffer := StringBuffer.new
			res.append("[")
			visitedTransition.indexedEach{ elem,eachContext |
				res.append(elem.name) 
				if(!eachContext.isLast) then res.append(">") end
				}
			res.append("]")
			stdio.writeln(res.toString)
			
			result := Bag<OrderedSet<Transition>>.new
			var clonedPath : OrderedSet<Transition> := OrderedSet<Transition>.new
			visitedTransition.each{e | clonedPath.add(e)} //Protection to side effect
			result.add(clonedPath)
		end
	}
	
	aspect class AbortingState{
	
		/*
		 * Return empty path
		 */
		operation visit(context : Context, visitedTransition : OrderedSet<Transition>) : Collection<OrderedSet<Transition>> is do
			stdio.writeln("Hello from ABORTING_STATE "+self.name)
			
			var res : StringBuffer := StringBuffer.new
			res.append("[")
			visitedTransition.indexedEach{ elem,eachContext |
				res.append(elem.name) 
				if(!eachContext.isLast) then res.append(">") end
				}
			res.append("]")
			stdio.writeln(res.toString)
			
			result := Bag<OrderedSet<Transition>>.new
			//Return a collection containing the path to the AbordingState
			//result.add(visitedTransition)
		end
	}
		
	aspect class Transition{
	
		//If not void: the transition was splited to catch solutions of the condition
		attribute conditionSolution : String
	
		operation visit(context : Context, visitedTransition : OrderedSet<Transition>) : Collection<OrderedSet<Transition>> is do
			stdio.writeln("Hello from TRANSITION "+self.name)
			
			if conditionSolution != void then
				stdio.writeln("{"+conditionSolution+"}")
			end
			
			result := self.outputState.visit(context,visitedTransition)
		end
		
		//Dummy clone
		operation copy() : Transition is do
			result := Transition.new
			result.inputState := self.inputState
			result.outputState := self.outputState
			result.description := self.description
			result.event := self.event
			result.condition := self.condition
			result.actions := self.actions
			result.name := self.name
			result.hid := self.hid
		end
		
	}
}

package org::malai::action{

	aspect class Action{
	
		/*
		 * Update the context
		 */
		operation visit(context : Context) : Void is do 
			context.addSolvedAvtion(self)
			stdio.writeln("Hello from ACTION "+self.clazz.name)
		end
	}
}
