using kermeta::standard::*
using kermeta::io::StdIO => stdio

using org::malai::instrument::*
using org::malai::interaction::*
using org::malai::action::*

using org::malai::generator::Context


package org::malai::instrument{

	aspect class Instrument {
	
		operation visit(context : Context) : Void is do 
			stdio.writeln("Hello from instrument "+self)
			self.links.each{elem | elem.visit(context)}
		end
		
	}
	
	aspect class Link{	
	
		attribute visitCounter : Integer
	
		operation visit(context : Context) : Void is do 
			if visitCounter == void then
				visitCounter := 1
			else
				visitCounter := visitCounter + 1
			end
			
			stdio.writeln("Hello from link "+self)
			
			var paths : Collection<OrderedSet<Transition>> := self.interaction.visit(context)
			paths.each{path |
					var t : Transition := path.last
					if t.outputState.isInstanceOf(TerminalState) then
						//TODO: Update & clone context
						self.action.visit(context)
					end
				}
		end
		
	}
}

package org::malai::interaction{

	aspect class Interaction{
	
		/*
		 * Visits all paths and return paths to TerminalState
		 */
		operation visit(context : Context) : Collection<OrderedSet<Transition>> is do 
		
			result := Bag<OrderedSet<Transition>>.new
			
			stdio.writeln("Hello from interaction "+self)
			
			if(self.initState != void) then
				var visitedTransitions :OrderedSet<Transition> := OrderedSet<Transition>.new
				result := self.initState.visit(context,visitedTransitions)
			end
		end
	}
		
	aspect class State{
	
		attribute nbVisits : Integer
		
		//Config: change this value to change the number of allowed loops
		operation nbMaxVisits() : Integer is result := 1

		/*
		 * Return all paths to TerminalState from this State
		 */
		operation visit(context : Context, visitedTransition : OrderedSet<Transition>) : Collection<OrderedSet<Transition>> is do
		
			result := Bag<OrderedSet<Transition>>.new
		
			if(nbVisits == void) then
				nbVisits := 0
				
				//Spliting transitions with condition parsing
				self.outputTransitions.each{elem | 
					if(elem.condition != void) then
						self.splitTransition(elem)
					end
					}
			end
			
			if(nbVisits < nbMaxVisits) then
				stdio.writeln("Hello from state "+self.name)	
				nbVisits := nbVisits + 1		
				self.outputTransitions.each{elem | 
					//if not visitedTransition.contains(elem) then //Avoid loop in the path
						visitedTransition.add(elem)
						var paths : Collection<OrderedSet<Transition>>
						paths := elem.visit(context,visitedTransition)
						result.addAll(paths)
						visitedTransition.remove(elem)
					//end
					}
			end				
		end
		
		/*
		 * If a condition is linked to the transition, it will be solved and the transition
		 * will be split as many as solutions found.
		 */
		operation splitTransition(t : Transition) : Void is do

			if t.conditionSolution == void then
				var parser : org::malai::conditionSolver::Parser := org::malai::conditionSolver::Parser.new
				var sols : Collection<String> := parser.getSolutions(t.condition)
				sols.indexedEach{sol,eachContext |
					if(eachContext.isLast) then
						t.conditionSolution := sol
					else
						var newTr : Transition := t.copy()
						newTr.conditionSolution := sol
						self.outputTransitions.add(newTr)
					end
					}
			end
		end
	}
	
	aspect class TerminalState{
	
		/*
		 * Return a collection containing the path to the TerminalState
		 */
		operation visit(context : Context, visitedTransition : OrderedSet<Transition>) : Collection<OrderedSet<Transition>> is do
			stdio.writeln("Hello from TerminalState "+self.name)
			
			var res : StringBuffer := StringBuffer.new
			res.append("[")
			visitedTransition.indexedEach{ elem,eachContext |
				res.append(elem.name) 
				if(!eachContext.isLast) then res.append(">") end
				}
			res.append("]")
			stdio.writeln(res.toString)
			
			result := Bag<OrderedSet<Transition>>.new
			result.add(visitedTransition)
		end
	}
	
	aspect class AbortingState{
	
		/*
		 * Return a collection containing the path to the AbordingState
		 */
		operation visit(context : Context, visitedTransition : OrderedSet<Transition>) : Collection<OrderedSet<Transition>> is do
			stdio.writeln("Hello from AbortingState "+self.name)
			
			var res : StringBuffer := StringBuffer.new
			res.append("[")
			visitedTransition.indexedEach{ elem,eachContext |
				res.append(elem.name) 
				if(!eachContext.isLast) then res.append(">") end
				}
			res.append("]")
			stdio.writeln(res.toString)
			
			result := Bag<OrderedSet<Transition>>.new
			result.add(visitedTransition)
		end
	}
		
	aspect class Transition{
	
		//If not void: the transition was splited to catch solutions of the condition
		attribute conditionSolution : String
	
		operation visit(context : Context, visitedTransition : OrderedSet<Transition>) : Void is do
			stdio.writeln("Hello from transition "+self.name)
			
			if conditionSolution != void then
				stdio.writeln("{"+conditionSolution+"}")
			end
			
			self.outputState.visit(context,visitedTransition)
		end
		
		//Dummy clone
		operation copy() : Transition is do
			result := Transition.new
			result.inputState := self.inputState
			result.outputState := self.outputState
			result.description := self.description
			result.event := self.event
			result.condition := self.condition
			result.actions := self.actions
			result.name := self.name
			result.hid := self.hid
		end
		
	}
}

package org::malai::action{

	aspect class Action{
	
		/*
		 * Update the context
		 */
		operation visit(context : Context) : Void is do 
		
			context.resolvedActions.add(self)
			stdio.writeln("Hello from action "+self)
		end
	}
}
